#define MAX_SYMBOL_LEN 64

static u64 hash_str(const char* str) {
  u64 res = 5381;
  for (int i = 0; i < MAX_SYMBOL_LEN; ++i) {
    int c = *(str+i);
    res = ((res << 5) + res) + c;
  }
  return res;
}

struct invoke_info {
  u64 invoke_total_count;
  u64 invoke_total_time;
  char symbol[MAX_SYMBOL_LEN];
  struct bpf_spin_lock lock;
};
BPF_HASH(symbol_map, u64, struct invoke_info);

struct display_info {
  u64 invoke_total_count;
  u64 invoke_total_time;
  char symbol[MAX_SYMBOL_LEN];
};
BPF_PERF_OUTPUT(invoke_events);

{% for symbol, function_pair in trace_symbol_dict.items() %}
int {{ function_pair[0] }}(struct pt_regs* ctx) {
  u64 hash_value = hash_str("{{ symbol }}");
  struct invoke_info* i = symbol_map.lookup(&hash_value);
  if (i == NULL) {
    struct invoke_info ii = {0};
    __builtin_memcpy(&ii.symbol, "{{ symbol }}", MAX_SYMBOL_LEN);
    symbol_map.update(&hash_value, &ii);
  }
  return 0;
}

int {{ function_pair[1] }}(struct pt_regs* ctx) {
  u64 hash_value = hash_str("{{ symbol }}");
  struct invoke_info* i = symbol_map.lookup(&hash_value);
  if (i == NULL) {
    return 0;
  }

  bpf_spin_lock(&i->lock);
  i->invoke_total_count++;
  i->invoke_total_time += 1;

  if (i->invoke_total_count % {{ record_per_round }} == 0) {
    struct display_info di = {0};
    di.invoke_total_count = i->invoke_total_count;
    di.invoke_total_time = i->invoke_total_time;
    __builtin_memcpy(&di.symbol, i->symbol, MAX_SYMBOL_LEN);
    invoke_events.perf_submit(ctx, &di, sizeof(struct display_info));
  }
  bpf_spin_unlock(&i->lock);
  return 0;
}
{% endfor %}
